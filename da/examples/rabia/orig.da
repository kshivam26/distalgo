import sys
import random
from queue import PriorityQueue
import time
from math import floor

class LogEntry:
    """Fictional log entries."""
    def __init__(self, client, command):
        self.client = client
        self.command = command

    def __str__(self):
        sl = ['LogEntry', str(self.client), str(self.command)]
        return ' : '.join(sl)

null_entry = (-1,-1,-1)

class Server(process):
    def setup(peers, maxTimeout, nfailure, seed):
        self.requestQ = PriorityQueue()
        self.seq = 0
        self.log = {}
        self.seed = seed
        self.maxTimeout = maxTimeout

        self.n = len(peers)
        self.f = nfailure
        self.peers = peers
        
        self.logDict = set()
    
    
    def run():
        while True:
            if self.requestQ.empty():
                await(some(received(('RequestForward', _))))
            else:
                # proposali <- first element in PQi that is not already in log
                proposal = self.requestQ.get()
                while proposal in self.logDict:
                    proposal = self.requestQ.get()

                # output <- WEAK-MVC(proposali, seq)
                outputMVC = self.WeakMVC(proposal, self.seq)

                # log[seq] <- output
                # seq <- seq + 1
                self.log[seq] = LogEntry(outputMVC[1], outputMVC[2])
                seq = seq + 1
                
                if outputMVC != null_entry:
                    self.logDict.add(outputMVC)
                
                # if output = null_entry or output != proposali
                # PQi.push(proposali)
                if outputMVC != proposal:
                    self.requestQ.put(proposal)
                
                if outputMVC in setof( (timestamp, serial, client) , received(('ClientRequest', serial, timestamp), from_=client)):
                    output(self.log[seq-1], " at index", seq-1, "applied to state machine.")
                    send(('Reply', outputMVC[1], self), to=outputMVC[2])

    def FindReturnValue(v, seq):
        # if ùë£ = 1 then
        #   Find value ùëö that appears ‚â• ‚åä ùëõ/2‚åã + 1 times in Proposal messages received in Phase 0
        #   Return ùëö
        # else
        #   Return ‚ä•        ‚ä≤return null value

        if v == 1:
            for m in setof(m, received(('Proposal', m, _seq))):
                if len(listof(p, received(('Proposal', _m, _seq), from_=p))) >= floor(self.n/2) + 1:
                    return m
        else:
            return (-1, -1, -1)
    
    def CommonCoinFlip(p):
        random.seed(self.seed+p)
        return random.random() > 0.5

    def WeakMVC(proposal, seq):
        outputMVC = null_entry

        # Send(Proposal, q) to all, Weak-MVC is invoked with q and seq
        for target in self.peers:
            send(('Proposal', proposal, seq), to=target)

        # wait until receiving >= n-f proposal messages
        if await( len(setof(peer, received(('Proposal', _, _seq), from_=peer))) >= self.n - self.f ):
            numProposals = len(setof(peer, received(('Proposal', _proposal, _seq), from_=peer)))
        elif timeout(self.maxTimeout):
            return outputMVC

        # if request ùëû appears ‚â• ‚åä ùëõ / 2‚åã + 1 times in Proposals then
        #    state <- 1
        # else state <- 0
        if numProposals >= floor(self.n/2) + 1:
            state = 1
        else:
            state = 0
        # p <- 1
        p = 1
        
        # while true do
        while True:
            # Send (State, p, state ) to all state can be 0 or 1
            for target in self.peers:
                send(('State', state, p, seq), to=target)
            # wait until receiving >= n-f phase-p state messages
            if await( len(setof(peer, received(('State', _, _p, _seq), from_=peer))) >= self.n - self.f ):
                numState0 = len(setof(peer, received(('State', 0, _p, _seq), from_=peer)))
                numState1 = len(setof(peer, received(('State', 1, _p, _seq), from_=peer)))
            elif timeout(self.maxTimeout):
                return outputMVC

            # if value ùë£ appears ‚â• ‚åä ùëõ/2‚åã + 1 times in States then
            #   ùë£ùëúùë°ùëí ‚Üê ùë£ 
            # else 
            #   ùë£ùëúùë°ùëí ‚Üê ? 

            if numState0 >= floor(n/2) + 1:
                vote = 0
            elif numState1 >= floor(n/2) + 1:
                vote = 1
            else:
                vote = -1 # ? is represented by -1
            
            # Send (vote, ùëù, ùë£ùëúùë°ùëí ) to all
            for target in self.peers:
                send(('Vote', vote, p, seq), to=target)
            
            # wait until receiving >= n-f phase-p vote messages
            if await( len(setof(peer, received(('Vote', _, _p, _seq), from_=peer))) >= self.n - self.f ):
                numVote0 = len(setof(peer, received(('Vote', 0, _p, _seq), from_=peer)))
                numVote1 = len(setof(peer, received(('Vote', 1, _p, _seq), from_=peer)))
            elif timeout(self.maxTimeout):
                return outputMVC

            # if a non-? value ùë£ appears ‚â• ùëì + 1 times in votes then 
            #   Return FindReturnValue(ùë£ )     ‚ä≤Termination
            # else if a non-? value ùë£ appears at least once in votes then 
            #   ùë†ùë°ùëéùë°ùëí ‚Üê ùë£ 
            # else 
            #    ùë†ùë°ùëéùë°ùëí ‚Üê CommonCoinFlip(ùëù)      ‚ä≤p-th coin flip

            if numVote0 >= self.f+1:
                return self.FindReturnValue(0, seq)
            if numVote1 >= self.f+1:
                return self.FindReturnValue(1, seq)
            elif numVote1 > 0:
                state = 1
            elif numVote0 > 0:
                state = 0
            else:
                state = int(self.CommonCoinFlip(p))
            p += 1

        return outputMVC   

    def receive(msg=('ClientRequest', serial, timestamp), from_=client):
        request = (timestamp, serial, client)
        for target in self.peers:
            send(('RequestForward', request), to=target)
    
    def receive(msg=('RequestForward', request), from_=server):
        self.requestQ.put(request)

    def receive(msg=('Proposal', proposal, seq), from_=server):
        return
        
    
    def receive(msg=('State', state, p, seq), from_=server):
        return
    
    def receive(msg=('Vote', vote, p, seq), from_=server):
        return

class Client(process):
    def setup(servers, nrequests, timeout): pass

    def run():
        random.seed(time.perf_counter())
        
        target = random.choice(servers)
        req = 0
        while req < nrequests:
            send(('ClientRequest', req, time.perf_counter()), to=target)
            if await(some(received(('Reply', _req, _)))):
                output("Request", req + 1, "complete.")
                req += 1
            elif timeout(timeout/1000):
                debug("Server", target, "timed out, choosing new one randomly.")
                target = random.choice(servers)

        send(('Done',), to=parent())

def main():
    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 1000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.00
    nfailure = int(sys.argv[6]) if len(sys.argv) > 6 else floor(nservers/2)
    servers = new(Server, num= nservers, send= send_failrate, )
    setup(servers, (servers, maxtimeout, nfailure, time.perf_counter()))
    clients = new(Client, num= nclients)
    setup(clients, (list(servers), nrequests, maxtimeout))
    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    output("All clients done.")
    end(servers)
