import sys
import random
from queue import PriorityQueue
import time
from math import floor

class LogEntry:
    """Fictional log entries."""
    def __init__(self, client, command):
        self.client = client
        self.command = command

    def __str__(self):
        sl = ['LogEntry', str(self.client), str(self.command)]
        return ' : '.join(sl)

null_entry = (-1,-1,-1)

class Server(process):
    def setup(peers, maxTimeout, nfailure, seed):
        # Priority Queue PQi for every replica
        self.requestQ = PriorityQueue()
        # current slot index
        self.seq = 0
        # dictionary to hold log entries
        self.log = {}
        self.n = len(peers)
        self.f = nfailure
        
        # dictionary to check if a request has already been added to the log
        self.logDict = set()
    
    
    def run():
        while True:
            await(not self.requestQ.empty())
            # proposali <- first element in PQi that is not already in log
            proposal = self.requestQ.get()
            while proposal in self.logDict:
                proposal = self.requestQ.get()

            # output <- WEAK-MVC(proposali, seq)
            outputMVC = self.WeakMVC(proposal, self.seq)

            # log[seq] <- output
            # seq <- seq + 1
            self.log[seq] = LogEntry(outputMVC[1], outputMVC[2])
            seq = seq + 1
            
            
            # if output = null_entry or output != proposali
            # PQi.push(proposali)
            if outputMVC != proposal:
                self.requestQ.put(proposal)
                if outputMVC != null_entry:
                    self.logDict.add(outputMVC)

            # send reply back to client if replica has received ClientRequest
            if outputMVC in setof( (request[1], request[0], client) , received(('ClientRequest', request), from_=client)):
                output(self.log[seq-1], " at index", seq-1, "applied to state machine.")
                send(('Reply', outputMVC[1], self), to=outputMVC[2])

    def FindReturnValue(v, seq):
        # if 𝑣 = 1 then
        #   Find value 𝑚 that appears ≥ ⌊ 𝑛/2⌋ + 1 times in Proposal messages received in Phase 0
        #   Return 𝑚
        # else
        #   Return ⊥        ⊲return null value

        if v == 1:
            for m in setof(m, received(('Proposal', m, _seq))):
                if len(listof(p, received(('Proposal', _m, _seq), from_=p))) >= floor(self.n/2) + 1:
                    return m
        else:
            return (-1, -1, -1)

    #  random binary number generator with the same seed across all replicas
    def CommonCoinFlip(p):
        random.seed(self.seed+p)
        return random.random() > 0.5

    def WeakMVC(proposal, seq):

        # Send(Proposal, q) to all, Weak-MVC is invoked with q and seq
        send(('Proposal', proposal, seq), to=self.peers)

        # wait until receiving >= n-f proposal messages
        if await( len(setof(peer, received(('Proposal', _, _seq), from_=peer))) >= self.n - self.f ):
            numProposals = len(setof(peer, received(('Proposal', _proposal, _seq), from_=peer)))
        elif timeout(self.maxTimeout):
            return null_entry

        # if request 𝑞 appears ≥ ⌊ 𝑛 / 2⌋ + 1 times in Proposals then
        #    state <- 1
        # else state <- 0
        if numProposals >= floor(self.n/2) + 1:
            state = 1
        else:
            state = 0
        # p <- 1
        p = 1
        
        # while true do
        while True:
            # Send (State, p, state ) to all state can be 0 or 1
            send(('State', state, p, seq), to=self.peers)

            # wait until receiving >= n-f phase-p state messages
            # if value 𝑣 appears ≥ ⌊ 𝑛/2⌋ + 1 times in States then
            #   𝑣𝑜𝑡𝑒 ← 𝑣 
            # else 
            #   𝑣𝑜𝑡𝑒 ← ?

            vote = -1 # ? is represented by -1
            if await( len(setof(peer, received(('State', _, _p, _seq), from_=peer))) >= self.n - self.f ):
                for v in setof(v, received(('State', v, _p, _seq))):
                    if len(setof(peer, received(('State', _v, _p, _seq), from_=peer))) >= floor(n/2) + 1:
                        vote = v
            elif timeout(self.maxTimeout):
                return null_entry
            
            # Send (vote, 𝑝, 𝑣𝑜𝑡𝑒 ) to all
            send(('Vote', vote, p, seq), to=self.peers)
            
            # wait until receiving >= n-f phase-p vote messages
            if await( len(setof(peer, received(('Vote', _, _p, _seq), from_=peer))) >= self.n - self.f ):
                numVote0 = len(setof(peer, received(('Vote', 0, _p, _seq), from_=peer)))
                numVote1 = len(setof(peer, received(('Vote', 1, _p, _seq), from_=peer)))
            elif timeout(self.maxTimeout):
                return null_entry

            if numVote0 >= self.f+1:
                return self.FindReturnValue(0, seq)
            if numVote1 >= self.f+1:
                return self.FindReturnValue(1, seq)
            elif numVote1 > 0:
                state = 1
            elif numVote0 > 0:
                state = 0
            else:
                state = int(self.CommonCoinFlip(p))
            p += 1

        return null_entry   

    # forward 〈 REQUEST, 𝑐 〉 to all other replicas
    def receive(msg=('ClientRequest', request), from_=client):
        # request[1] - timestamp from client
        # request[0] - serial from client
        request = (request[1], request[0], client)
        send(('RequestForward', request), to=self.peers)

    # 𝑃𝑄𝑖.𝑝𝑢𝑠ℎ(〈 REQUEST, 𝑐 〉) 
    def receive(msg=('RequestForward', request), from_=server):
        self.requestQ.put(request)

class Client(process):
    def setup(servers, nrequests, timeout): pass

    def run():
        random.seed(time.perf_counter())
        
        target = random.choice(servers)
        req = 0
        while req < nrequests:
            request = (req, time.perf_counter())
            send(('ClientRequest', request), to=target)
            if await(some(received(('Reply', _req, _)))):
                output("Request", req + 1, "complete.")
                req += 1
            elif timeout(timeout/1000):
                debug("Server", target, "timed out, choosing new one randomly.")
                target = random.choice(servers)

        send(('Done',), to=parent())

def main():
    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 1000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.00
    nfailure = int(sys.argv[6]) if len(sys.argv) > 6 else floor(nservers/2)
    servers = new(Server, num= nservers, send= send_failrate, )
    setup(servers, (servers, maxtimeout, nfailure, time.perf_counter()))
    clients = new(Client, num= nclients)
    setup(clients, (list(servers), nrequests, maxtimeout))
    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    output("All clients done.")
    end(servers)
