import sys
import random
from queue import PriorityQueue
import time
from math import floor

class LogEntry:
    """Fictional log entries."""
    def __init__(self, timeStamp, client, command):
        self.timeStamp = timeStamp
        self.client = client
        self.command = command
        #self.server = server

    def __str__(self):
        sl = ['LogEntry', str(self.timeStamp), str(self.client), str(self.command)]
        return ':'.join(sl)

null_entry = LogEntry(-1,-1,-1)

class Server(process):
    def setup(peers, maxTimeout, nfailure, seed):
        self.requestQ = PriorityQueue()
        self.currentClientPendingRequests = set()
        self.seq = 0
        self.log = {}
        self.seed = seed

        self.n = len(peers)
        self.f = nfailure
        self.peers = peers

        self.proposals = {}
        self.num_proposals = 0
        

        self.num_state_messages = {}
        self.states = {}
        
        self.num_vote_messages = {}
        self.votes = {}
    
    def run():
        output("test")
        while True:
            if not self.requestQ.empty():
                proposal = self.requestQ.get()
                outputMVC = self.WeakMVC(proposal, self.seq)
                self.log[seq] = outputMVC
                if outputMVC is not proposal:
                    self.requestQ.put(proposal)
                seq = seq + 1
                if outputMVC is not null_entry and outputMVC in self.currentClientPendingRequests:
                    output(outputMVC, " at index", seq-1, "applied to state machine.")
                    send(('Reply', outputMVC.command, self), to=outputMVC.client)
                    self.currentClientPendingRequests.remove(outputMVC)

    def FindReturnValue(v):
        if v is 1:
            m = list(self.proposals.keys())[0]
            for key in self.proposals:
                if self.proposals[key] > self.proposals[m]:
                    m = key
            #m = max(self.proposals, key=self.proposals.get)
            return m
        else:
            return LogEntry(-1, -1, -1)
    
    def CommonCoinFlip(p):
        random.seed(self.seed+p)
        return random.random() > 0.5

    def WeakMVC(proposal, seq):
        output = null_entry

        for target in self.peers:
            send(('Proposal', proposal, seq), to=target)
        # wait until receiving n-f proposal messages
        await(self.num_proposals >= self.n - self.f)
        state = 0
        if self.proposals[proposal] >= floor(n/2) + 1:
            state = 1
        p = 1
        while True:
            for target in self.peers:
                send(('State', state, p), to=target)
            # wait until receiving n-f phase-p state messages
            await(self.num_state_messages[p] >= self.n - self.f)
            vote = -1
            v = list(self.states[p].keys())[0]
            for key in self.states[p]:
                if self.states[p][key] > self.states[p][v]:
                    v = key
            #v = max(self.states[p], key=self.states[p].get)
            if self.states[p][v] >= floor(n/2) + 1:
                vote = v
            self.votes[p][0] = self.votes[p][1] = 0
            for target in self.peers:
                send(('Vote', vote, p), to=target)
            
            # wait until receiving n-f phase-p vote messages
            await(self.num_vote_messages[p] >= self.n - self.f)
            maxVotes = list(self.votes[p].keys())[0]
            for key in self.votes[p]:
                if self.votes[p][key] > self.votes[p][v]:
                    maxVotes = key
            #maxVotes = max(self.votes[p], key=self.votes[p].get)
            if maxVotes >= self.f+1 and maxVotes is not -1:
                return self.FindReturnValue(maxVotes)
            elif self.votes[p][0] > 0:
                state = 0
            elif self.votes[p][1] > 0:
                state = 1
            else:
                state = self.CommonCoinFlip(p)
            p += 1

        return output   

    def receive(msg=('ClientRequest', serial), from_=client):
        output(serial, " Client Request from ", client)
        request = LogEntry(time.perf_counter(), serial, client)
        self.currentClientPendingRequests.add(request)
        self.requestQ.put(request)
        for target in self.peers:
            send(('RequestForward', request), to=target)
    
    def receive(msg=('RequestForward', request), from_=server):
        # hack to ensure that there is no duplicate in the server sending the broadcast
        if request not in self.currentClientPendingRequests:
            self.requestQ.put(request)

    def receive(msg=('Proposal', proposal, seq), from_=server):
        self.proposals[proposal]= self.proposals.setdefault(proposal, 0) + 1
        self.num_proposals += 1
    
    def receive(msg=('State', state, p), from_=server):
        if p in self.states:
            self.states[p][state] = self.states[p].setdefault(state, 0) + 1
        else:
            self.states[p] = {state:1}
        self.num_state_messages[p] = self.num_state_messages.setdefault(p, 0) + 1
    
    def receive(msg=('Vote', vote, p), from_=server):
        if p in self.votes:
            self.votes[p][vote] = self.votes[p].setdefault(vote, 0) + 1
        else:
            self.votes[p] = {vote:1}
        self.num_vote_messages[p] = self.num_vote_messages.setdefault(p, 0) + 1

class Client(process):
    def setup(servers, nrequests, timeout): pass

    def run():
        target = random.choice(servers)
        req = 0
        while req < nrequests:
            send(('ClientRequest', req), to=target)
            output("sent CR to", target)
            if await(some(received(('NotLeader', _req, leader)),
                          has= leader is not None)):
                debug("Wrong server, changing to", leader)
                target = leader
                reset(received)
            elif some(received(('Reply', _req, _))):
                output("Request", req + 1, "complete.")
                req += 1
            elif timeout(timeout/1000):
                debug("Server", target, "timed out, choosing new one randomly.")
                target = random.choice(servers)

        send(('Done',), to=parent())

def main():
    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 3000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0
    nfailure = int(sys.argv[6]) if len(sys.argv) > 6 else floor(nservers/2)
    servers = new(Server, num= nservers, send= send_failrate, )
    setup(servers, (servers, maxtimeout, nfailure, time.perf_counter()))
    clients = new(Client, num= nclients)
    setup(clients, (list(servers), nrequests, maxtimeout))
    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    output("All clients done.")
    end(servers)
