import sys
import random
from queue import PriorityQueue
import time
from math import floor

class LogEntry:
    """Fictional log entries."""
    def __init__(self, timeStamp, client, command):
        self.timeStamp = timeStamp
        self.client = client
        self.command = command

    def __str__(self):
        sl = ['LogEntry', str(self.timeStamp), str(self.client), str(self.command)]
        return ' : '.join(sl)

null_entry = (-1,-1,-1)

class Server(process):
    def setup(peers, maxTimeout, nfailure, seed):
        self.requestQ = PriorityQueue()
        self.currentClientPendingRequests = set()
        self.seq = 0
        self.log = {}
        self.seed = seed

        self.n = len(peers)
        self.f = nfailure
        self.peers = peers

        self.logDict = set()
    
    
    def run():
        while True:
            if self.requestQ.empty():
                await(some(received(('RequestForward', _))))
            else:
                # proposali <- first element in PQi that is not already in log
                proposal = self.requestQ.get()
                while proposal in self.logDict:
                    proposal = self.requestQ.get()

                # output <- WEAK-MVC(proposali, seq)
                outputMVC = self.WeakMVC(proposal, self.seq)

                # log[seq] <- output
                # seq <- seq + 1
                self.log[seq] = LogEntry(outputMVC[0], outputMVC[1], outputMVC[2])
                seq = seq + 1
                
                if outputMVC != null_entry:
                    self.logDict.add(outputMVC)
                
                # if output = null_entry or output != proposali
                # PQi.push(proposali)
                if outputMVC != proposal:
                    self.requestQ.put(proposal)
                
                if outputMVC in self.currentClientPendingRequests:
                    output(outputMVC, " at index", seq-1, "applied to state machine.")
                    send(('Reply', outputMVC[1], self), to=outputMVC[2])
                    self.currentClientPendingRequests.remove(outputMVC)

    def FindReturnValue(v, seq):
        # if ùë£ = 1 then
        #   Find value ùëö that appears ‚â• ‚åä ùëõ/2‚åã + 1 times in Proposal messages received in Phase 0
        #   Return ùëö
        # else
        #   Return ‚ä•        ‚ä≤return null value

        if v == 1:
            for m in setof(m, received(('Proposal', m, _seq))):
                if len(listof(p, received(('Proposal', _m, _seq), from_=p))) >= floor(self.n/2) + 1:
                    #output("FRV:", m, "count:", len(listof(p, received(('Proposal', _m, _), from_=p))))
                    return m
        else:
            return (-1, -1, -1)
    
    def CommonCoinFlip(p):
        random.seed(self.seed+p)
        return random.random() > 0.5

    def WeakMVC(proposal, seq):
        outputMVC = null_entry
        #output("WeakMVC proposali:", proposal, "seq:", seq, "len(PQi):", self.requestQ.qsize())

        # Send(Proposal, q) to all, Weak-MVC is invoked with q and seq
        for target in self.peers:
            send(('Proposal', proposal, seq), to=target)

        # wait until receiving >= n-f proposal messages
        await( len(setof(peer, received(('Proposal', _, _seq), from_=peer))) >= self.n - self.f )
        nproposal = len(setof(peer, received(('Proposal', _proposal, _seq), from_=peer)))

        # if request ùëû appears ‚â• ‚åä ùëõ / 2‚åã + 1 times in Proposals then
        #    state <- 1
        # else state <- 0
        if nproposal >= floor(self.n/2) + 1:
            state = 1
        else:
            state = 0
        # p <- 1
        p = 1
        #output("proposal phase:",proposal, "state:",state, "count:", nproposal)
        # while true do
        while True:
            # Send (State, p, state ) to all state can be 0 or 1
            for target in self.peers:
                send(('State', state, p, seq), to=target)
            # wait until receiving >= n-f phase-p state messages
            await( len(setof(peer, received(('State', _, _p, _seq), from_=peer))) >= self.n - self.f )
            
            numState0 = len(setof(peer, received(('State', 0, _p, _seq), from_=peer)))
            numState1 = len(setof(peer, received(('State', 1, _p, _seq), from_=peer)))

            # if value ùë£ appears ‚â• ‚åä ùëõ/2‚åã + 1 times in States then
            # ùë£ùëúùë°ùëí ‚Üê ùë£ else ùë£ùëúùë°ùëí ‚Üê ? 

            if numState0 >= floor(n/2) + 1:
                vote = 0
            elif numState1 >= floor(n/2) + 1:
                vote = 1
            else:
                vote = -1 # ? is represented by -1
            
            #output("state phase -",p,"state0:",numState0,"state1:",numState1, "vote:", vote)

            # Send (vote, ùëù, ùë£ùëúùë°ùëí ) to all
            for target in self.peers:
                send(('Vote', vote, p, seq), to=target)
            
            # wait until receiving >= n-f phase-p vote messages
            await( len(setof(peer, received(('Vote', _, _p, _seq), from_=peer))) >= self.n - self.f )
            #output("vote phase -",p,"vote0:",len(setof(peer, received(('Vote', 0, p), from_=peer))), "vote1:", len(setof(peer, received(('Vote', 1, p), from_=peer))), "vote-1:", len(setof(peer, received(('Vote', -1, p), from_=peer))))
            
            vote0 = len(setof(peer, received(('Vote', 0, _p, _seq), from_=peer)))
            vote1 = len(setof(peer, received(('Vote', 1, _p, _seq), from_=peer)))

            # if a non-? value ùë£ appears ‚â• ùëì + 1 times in votes then 
            #   Return FindReturnValue(ùë£ ) ‚ä≤Termination
            # else if a non-? value ùë£ appears at least once in votes then 
            #   ùë†ùë°ùëéùë°ùëí ‚Üê ùë£ 
            # else 
            #    ùë†ùë°ùëéùë°ùëí ‚Üê CommonCoinFlip(ùëù)      ‚ä≤ùëù-th coin flip

            if vote0 >= self.f+1:
                return self.FindReturnValue(0, seq)
            if vote1 >= self.f+1:
                return self.FindReturnValue(1, seq)
            elif vote1 > 0:
                state = 1
            elif vote0 > 0:
                state = 0
            else:
                state = int(self.CommonCoinFlip(p))
            p += 1

        return outputMVC   

    def receive(msg=('ClientRequest', serial), from_=client):
        output( len(setof(c, received(('ClientRequest', _), from_=c)))  )
        request = (time.perf_counter(), serial, client)
        output(request, " Client Request from ", client)
        self.currentClientPendingRequests.add(request)
        for target in self.peers:
            send(('RequestForward', request), to=target)
    
    def receive(msg=('RequestForward', request), from_=server):
        #output("RequestForward:", request, " from:", server)
        self.requestQ.put(request)

    def receive(msg=('Proposal', proposal, seq), from_=server):
        #output("Received proposal:", proposal, "for seq:", seq, "from:",server)
        return
        
    
    def receive(msg=('State', state, p, seq), from_=server):
        #output("Received phase - ",p,"message with state:",state, "from:",server)
        return
    
    def receive(msg=('Vote', vote, p, seq), from_=server):
        return

class Client(process):
    def setup(servers, nrequests, timeout): pass

    def run():
        random.seed(time.perf_counter())
        
        target = random.choice(servers)
        req = 0
        while req < nrequests:
            send(('ClientRequest', req), to=target)
            #output("sent CR:", req, " to", target)
            if await(some(received(('Reply', _req, _)))):
                output("Request", req + 1, "complete.")
                req += 1
            elif timeout(timeout/1000):
                debug("Server", target, "timed out, choosing new one randomly.")
                target = random.choice(servers)

        send(('Done',), to=parent())

def main():
    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 3000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0
    nfailure = int(sys.argv[6]) if len(sys.argv) > 6 else floor(nservers/2)
    servers = new(Server, num= nservers, send= send_failrate, )
    setup(servers, (servers, maxtimeout, nfailure, time.perf_counter()))
    clients = new(Client, num= nclients)
    setup(clients, (list(servers), nrequests, maxtimeout))
    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    output("All clients done.")
    end(servers)
